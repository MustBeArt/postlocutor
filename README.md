# postlocutor
## Prototype Receiver for Opulent Voice

This is a simple receiver for the UDP-transported version of
Opulent Voice frames created by Interlocutor.

See https://github.com/Abraxas3d/interlocutor

Derived from code generated by Claude based on Interlocutor.

The frame structure is now the baseline Opulent Voice structure.

Might need this to run:
```sh
export DYLD_LIBRARY_PATH=/opt/homebrew/opt/opus/lib:$DYLD_LIBRARY_PATH
```

### Install Dependencies and Run

On macOS,
```
brew install portaudio
pip3 install opuslib pyaudio cobs emoji_data_python scapy
python3 opulent_voice_receiver.py
```
Or, using UV,
```
brew install portaudio
uv init
uv venv
source .venv/bin/activate
uv pip install opuslib pyaudio cobs emoji_data_python scapy
uv run opulent_voice_receiver.py
```

### Summary of Major Classes

#### class OpulentVoiceProtocol (aka OPV)

`OpulentVoiceProtocol` encapsulates the Opulent Voice frame header and
protocol knowledge.

It provides a number of constant values and one method, `parse_frame()`,
which extracts the fields of the frame header.

#### class AudioPlayer

`AudioPlayer` uses `pyaudio` (which uses PortAudio) to decode Opus voice
packets and send the decoded audio samples to the default audio output
device.

It manages a short queue of pending decoded audio frames. The queue is
filled by calls to the method `decode_and_queue_audio()`, and emptied by
callbacks to the method `audio_callback()` sent by itself.

It provides `start()` and `stop()` methods, which are called by the methods
of the same names of the `OpulentVoiceReceiver` object.

It keeps some statistics, which can be copied out by calling the
`get_stats()` method.

#### class OpulentVoiceReceiver:

`OpulentVoiceReceiver` operates the receiver overall.

It accepts the incoming UDP-encapsulated packets by opening a socket
and operating a separate thread running the `listen_loop()` method repeatedly.
That thread blocks on a `recvfrom()` call until a packet arrives, then calls
`process_frame()` to handle it.

`process_frame()` is also part of `OpulentVoiceReceiver`. This method should
(but does not yet) feed the non-header portion of the UDP-encapsulated
payload to the COBS decoder. If this results in the completion of a COBS
packet, the COBS-decoded data from that packet is further analyzed by
`process_COBS_packet()`, which checks for a valid UDP header and examines
the destination IP address and port number. If this matches criteria for
one of the services known to Opulent Voice, the packet is further processed
according to the specified service. Otherwise, the packet is passed through
to the host's network stack (but not yet).

`process_COBS_packet()` acts as follows:

* When handling a voice frame, it invokes AudioPlayer's
`decode_and_queue_audio()` method to play back the received audio.

* When handling a text message, it fetches the station ID from the
frame header, decodes it, and prints a line consisting of the station ID,
a special icon marking this as a text message, and the text data from
the packet payload.

* When handling a control message, it should (but does not yet) act
on the contents of the control message. Currently, a control message is
handled much like a text message.

### Summary of Data/Control Flow

* main creates an `OpulentVoiceReceiver`
    - `OpulentVoiceReceiver.__init__()` instantiates an `OpulentVoiceProtocol`
    - `OpulentVoiceReceiver.__init__()` instantiates an `AudioPlayer`

* main calls `OpulentVoiceReceiver.start()` and then goes into a
loop calling `time.sleep(1)` until interrupted.

* `OpulentVoiceReceiver.start` then:
    - creates and starts a daemon thread running 
    `OpulentVoiceReceiver.listen_loop()` to receive the encapsulated
    Opulent Voice Packets.

    - 

* `listen_loop()` sits in a loop calling `recvfrom()` on the UDP socket,
which blocks and returns exactly one packet. This loop continues until
`self.running` is false. Each time a packet is received, it is passed
to `self.process_frame()`

* `process_frame()` calls `self.protocol.parse_frame()` to extract the fields
of the frame header (plus a timestamp) into a dictionary, which is returned.
The payload, which is an IP packet, is passed into Scapy, resulting in a
Scapy packet called `pkt`.  We check that it's an IP/UDP packet, confirm its
checksums, and get the destination UDP port number. The port number is
used to determine which service (voice, text, control) owns the packet.

    - if it's voice, we send the data to `self.audio_player.decode_and_queue_audio()`,
which calls the Opus decoder in `self.decoder.decode()`, and adds the resulting
frame of audio samples to `self.audio_queue`. Meanwhile, `self.audio_player`
(which is an `AudioPlayer`) is pulling decoded audio frames from `self.audio_queue`
via `audio_callback()`, and streaming them to the default audio output device.

    - if it's a text message, we decode the `station_id` to ASCII and print
    it with the text message data to the screen.

    - if it's a control message, we (currently) just output the text of the
    control message to the screen, along with the encapsulating host's
    IP address.

* If, on the other hand, the packet isn't IP/UDP or its destination port
isn't one known to Opulent Voice, we currently discard it. Eventually,
this packet will be passed through to the host's network stack.
